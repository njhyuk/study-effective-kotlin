# item 20 - 일반적인 알고리즘을 반복해서 구현하지 말라

* 알고리즘은 특정 프로젝트에 국한된 것이 아닌 수학적 연산, 수집처럼 별도의 모듈 또는 라이브러리로 분리 할 수 있는걸 의미함
* 다음과 같이 숫자를 특정 범위에 맞추는 간단한 알고리즘 예시
  ![](item%2020%20-%20%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84%20%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C%20%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80%20%EB%A7%90%EB%9D%BC/image.png)<!-- {"width":540} -->
* 위 알고리즘은 stdlib 의 coerceIn 확장 함수가 이미 있다
  ![](item%2020%20-%20%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84%20%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C%20%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80%20%EB%A7%90%EB%9D%BC/image%202.png)<!-- {"width":678} -->
* 이미 있는걸 활용하면
  * 코드 작성속도가 빨라진다.
  * 함수의 이름만 봐도 무엇을 하는지 확실하게 알 수 있다.
  * 직접 구현할때 발생하는 실수를 줄일 수 있다.
  * 한번만 최적화 하면 모든곳이 최적화 혜택을 받을 수 있다.

## 표준 라이브러리 살펴보기
* 일반적인 알고리즘은 대부분 구현되어 있다.
* stdlib 은 확장 함수를 활용해서 만들어진 대표적인 표준 라이브러리
* 자세히 살펴보지 않으면 계속해서 같은 함수를 여러번 만들게 될 것
* 예를들어 다음은 어떤 자료형은 다른 자료형으로 매핑하는 코드
* ![](item%2020%20-%20%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84%20%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C%20%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80%20%EB%A7%90%EB%9D%BC/image%203.png)<!-- {"width":761} -->
* 굳이 위와같이 작성할 필요 없이 map 함수를 사용하면 됨
  * 이는 코틀린에서 찾아볼 수 없는 자바빈 패턴
  * 그래도 써야겠다면 다음과 같이 최소한 apply 를 활용해서, 모든 단일 객체들의 프로퍼티를 암묵적으로 설정하라
* ![](item%2020%20-%20%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84%20%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C%20%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80%20%EB%A7%90%EB%9D%BC/image%204.png)

## 나만의 유틸리티 구현하기
상황에 따라 없는 알고리즘이 필요할 수 있다.
모든 숫자의 곱을 계산하는 라이브러리가 필요한 경우? 범용 유틸리티 함수로 정의
![](item%2020%20-%20%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84%20%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C%20%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80%20%EB%A7%90%EB%9D%BC/image%209.png)<!-- {"width":720} -->
* product 라는 이름이 숫자를 곱할 거라는 것은 대부분 예측
* 동일한 함수를 모르고 여러번 만들 수 있음
  * 모든 함수는 테스트 되어야하고, 기억 되어야 하며, 유지보수 되어야함
    * 함수를 만들때는 이런 비용이 생길걸 고려 해야함
  * 기존 함수가 있는지 만들기 전에 탐색하자
* 코틀린 stdlib 에 사실 product 함수가 이미 있다.
* 톱레벨 함수, 프로퍼티 위임, 클래스로 만들어도 좋지만 확장 함수의 장점은
  * 함수는 상태를 유지하지 않으므로 행위를 나타내기 좋음
    * 부가 작용(side-effect)이 없는 경우 더 좋음
  * 톰레벨 함수와 비교해서 확장 함수는 구체적인 타입이 있는 객체에서만 사용을 제한할 수 있으므로 좋다
  * 수정할 객체를 아규먼트로 전달받아 사용하는 것 보다는 확장 리시버로 사용하는 것이 가독성이 좋다
  * 자동완성 기능으로 제안이 이우러져 쉽게 찾을 수 있다
    * **TextUtils.isEmply("Text")** 보다 **"Text".isEmply()**

#이펙티브-코틀린
